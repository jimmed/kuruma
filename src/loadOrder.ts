import { Tree, generateTree } from "./dependencyTree";
import { SyncRepositoriesArgs } from "./syncRepositories";
import { getConfig } from "./lib/configFile";
import { getManifestsFromConfig } from "./lib/manifest";
import {
  resolveDependenciesFromManifests,
  warnOnMissingDependencies,
  Dependency,
  isDependencyOf,
} from "./lib/dependencies";

const serverStartSnippetHeader = `# GENERATED BY KURUMA`;

export interface OutputLoadOrderArgs extends SyncRepositoriesArgs {}

export const outputLoadOrder = async (args: OutputLoadOrderArgs) => {
  const config = await getConfig(args.config);
  const manifests = await getManifestsFromConfig(config, args.cache);
  const dependencies = resolveDependenciesFromManifests(manifests);
  warnOnMissingDependencies(dependencies);

  const nodes = dependencies.map((dep) => new ModuleNode(dep));
  nodes.forEach((node) => {
    node.source.requires.forEach((dependency) => {
      const depNodes = nodes.filter(
        (nod) => nod.source.provides === dependency
      );
      if (!depNodes.length) {
        throw new Error(`Could not find dependency "${dependency}"`);
      }
      if (depNodes.length > 1) {
        throw new Error(
          `${depNodes
            .map((node) => node.source.module)
            .join(", ")} all provide ${dependency}`
        );
      }
      node.addDependency(depNodes[0]);
    });
  });

  const entrypoints = nodes.filter(
    (node) =>
      node.requires.size > 0 &&
      !nodes.some((otherNode) => otherNode.requires.has(node))
  );

  const resolved = new Set<ModuleNode>();
  entrypoints.forEach((node) => resolveDeps(node, resolved));
  if (resolved.size !== dependencies.length) {
    console.warn(
      `Expected to generate ${dependencies.length} deps, but got ${resolved.size}`
    );
  }
  resolved.forEach((node) => {
    console.log(
      `start ${node.source.provides}; ${
        node.source.provides === node.source.module
          ? ""
          : `# from ${node.source.module}`
      }`.trimEnd()
    );
  });
};

const resolveDeps = (node: ModuleNode, resolved: Set<ModuleNode>) => {
  node.requires.forEach((depNode) => resolveDeps(depNode, resolved));
  resolved.add(node);
};

class ModuleNode {
  requires = new Set<ModuleNode>();
  constructor(public readonly source: Dependency) {}
  addDependency(dependency: ModuleNode) {
    this.requires.add(dependency);
  }
}
