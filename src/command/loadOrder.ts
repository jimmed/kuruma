import { getConfig } from "../lib/configFile";
import {
  Dependency,
  resolveDependenciesFromManifests,
  warnOnMissingDependencies,
} from "../lib/dependencies";
import { getManifestsFromConfig } from "../lib/manifest";
import { SyncRepositoriesArgs } from "./sync";

const serverStartSnippetHeader = `# GENERATED BY KURUMA`;

export interface OutputLoadOrderArgs extends SyncRepositoriesArgs {}

export const outputLoadOrder = async (args: OutputLoadOrderArgs) => {
  const config = await getConfig(args.config);
  const manifests = await getManifestsFromConfig(config, args.cache);
  const dependencies = resolveDependenciesFromManifests(manifests);
  warnOnMissingDependencies(dependencies);

  const nodes = dependencies.map((dep) => new ResourceNode(dep));
  nodes.forEach((node) => {
    node.source.requires.forEach((dependency) => {
      const depNodes = nodes.filter(
        (nod) => nod.source.provides === dependency
      );
      if (!depNodes.length) {
        throw new Error(`Could not find dependency "${dependency}"`);
      }
      if (depNodes.length > 1) {
        throw new Error(
          `${depNodes
            .map((node) => node.source.resource)
            .join(", ")} all provide ${dependency}`
        );
      }
      node.addDependency(depNodes[0]);
    });
  });

  const entrypoints = nodes.filter(
    (node) =>
      node.requires.size > 0 &&
      !nodes.some((otherNode) => otherNode.requires.has(node))
  );

  const dependencyFree = nodes.filter((node) => node.requires.size === 0);

  const resolved = new Set<ResourceNode>(dependencyFree);
  entrypoints.forEach((node) => resolveDeps(node, resolved));
  console.log("# GENERATED BY KURUMA (https://npm.im/kuruma-cli)");
  resolved.forEach((node) => {
    const annotations = [];
    if (node.source.provides !== node.source.resource) {
      annotations.push(`provided by ${node.source.resource}`);
    }
    if (node.requires.size) {
      annotations.push(`requires ${node.source.requires.join(", ")}`);
    }
    console.log(
      `start ${node.source.provides};${
        annotations.length ? ` # ${annotations.join("; ")}` : ""
      }`
    );
  });
};

const resolveDeps = (node: ResourceNode, resolved: Set<ResourceNode>) => {
  node.requires.forEach((depNode) => resolveDeps(depNode, resolved));
  resolved.add(node);
};

class ResourceNode {
  requires = new Set<ResourceNode>();
  constructor(public readonly source: Dependency) {}
  addDependency(dependency: ResourceNode) {
    this.requires.add(dependency);
  }
}
